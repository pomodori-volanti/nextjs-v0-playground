import fs from "fs"
import path from "path"

// Enhanced version with better error handling and logging
function readAppDirectory(dir = "app"): string[] {
  const routes: string[] = []
  const appPath = path.join(process.cwd(), dir)

  if (!fs.existsSync(appPath)) {
    console.warn(`âš ï¸  App directory not found: ${appPath}`)
    return routes
  }

  function traverse(currentPath: string, routePath = "") {
    try {
      const files = fs.readdirSync(currentPath)

      for (const file of files) {
        const filePath = path.join(currentPath, file)
        const stat = fs.statSync(filePath)

        if (stat.isDirectory() && !file.startsWith("_") && !file.startsWith(".")) {
          const routeSegment = file.startsWith("[") && file.endsWith("]") ? `${file}` : file

          if (!["api", "components", "lib", "utils", "styles", "public"].includes(file)) {
            const newRoutePath = routePath === "" ? `/${routeSegment}` : `${routePath}/${routeSegment}`

            const hasPage =
              fs.existsSync(path.join(filePath, "page.tsx")) || fs.existsSync(path.join(filePath, "page.js"))
            const hasRoute =
              fs.existsSync(path.join(filePath, "route.tsx")) || fs.existsSync(path.join(filePath, "route.js"))

            if (hasPage || hasRoute) {
              routes.push(newRoutePath)
              console.log(`ðŸ“„ Found route: ${newRoutePath}`)
            }

            traverse(filePath, newRoutePath)
          }
        }
      }
    } catch (error) {
      console.error(`âŒ Error reading directory ${currentPath}:`, error.message)
    }
  }

  // Add root route if page.tsx exists
  if (fs.existsSync(path.join(appPath, "page.tsx")) || fs.existsSync(path.join(appPath, "page.js"))) {
    routes.push("/")
    console.log("ðŸ“„ Found route: /")
  }

  traverse(appPath)
  return routes
}

function generateRouteTypes() {
  console.log("ðŸš€ Starting route type generation...")

  const routes = readAppDirectory()

  if (routes.length === 0) {
    console.warn("âš ï¸  No routes found!")
    return
  }

  const routeType = routes.map((route) => `'${route}'`).join(" | ")

  const content = `// Auto-generated by scripts/generate-route-types.ts
// Last updated: ${new Date().toISOString()}
// Do not edit manually

export type AppRoute = ${routeType}

// Typed routes object
export const ROUTES = {
${routes
  .map((route) => {
    const constName =
      route
        .replace(/\//g, "_")
        .replace(/\[([^\]]+)\]/g, "$1")
        .replace(/^_/, "")
        .toUpperCase() || "ROOT"

    return `  ${constName}: '${route}' as const,`
  })
  .join("\n")}
} as const

// Route validation function
export function isValidRoute(route: string): route is AppRoute {
  return [${routes.map((r) => `'${r}'`).join(", ")}].includes(route as AppRoute)
}

// Get all available routes
export function getAllRoutes(): AppRoute[] {
  return [${routes.map((r) => `'${r}'`).join(", ")}]
}
`

  // Ensure lib directory exists
  const libDir = path.join(process.cwd(), "lib")
  if (!fs.existsSync(libDir)) {
    fs.mkdirSync(libDir, { recursive: true })
  }

  const outputPath = path.join(libDir, "routes.ts")
  fs.writeFileSync(outputPath, content)

  console.log(`âœ… Generated ${routes.length} route types in ${outputPath}`)
}

// Run if called directly
if (require.main === module) {
  generateRouteTypes()
}

export { generateRouteTypes }
